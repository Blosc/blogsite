<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blosc Main Blog Page  (Posts about Zstandard)</title><link>http://blosc.org/</link><description></description><atom:link href="http://blosc.org/categories/zstandard.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2022 &lt;a href="mailto:blosc@blosc.org"&gt;The Blosc Developers&lt;/a&gt; </copyright><lastBuildDate>Fri, 11 Mar 2022 11:49:38 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Testing PGO with LZ4 and Zstd codecs</title><link>http://blosc.org/posts/codecs-pgo/</link><dc:creator>Francesc Alted</dc:creator><description>&lt;p&gt;In &lt;a class="reference external" href="http://blosc.org/posts/blosclz-tuning/"&gt;past week's post&lt;/a&gt; I was showing how the PGO (&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Profile-guided_optimization"&gt;Profile Guided Optimization&lt;/a&gt;) capability in modern compilers allowed for a good increase in the performance of the BloscLZ codec.  Today I'd like to test how the PGO optimization affected the speed of the same &lt;a class="reference external" href="https://github.com/Blosc/c-blosc2/blob/master/bench/bench.c"&gt;synthetic benchmark&lt;/a&gt; that comes with C-Blosc2 for the two other of the most used codecs in Blosc: &lt;a class="reference external" href="http://lz4.github.io/lz4/"&gt;LZ4&lt;/a&gt; and &lt;a class="reference external" href="http://facebook.github.io/zstd/"&gt;Zstd&lt;/a&gt;.&lt;/p&gt;
&lt;section id="lz4-1"&gt;
&lt;h2&gt;LZ4&lt;/h2&gt;
&lt;p&gt;First, for GCC without PGO:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="lz4-old-c" src="http://blosc.org/images/codecs-pgo/lz4-comp-gcc-6.3.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="lz4-old-d" src="http://blosc.org/images/codecs-pgo/lz4-decomp-gcc-6.3.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Now with PGO enabled:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="lz4-pgo-c" src="http://blosc.org/images/codecs-pgo/lz4-comp-pgo.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="lz4-pgo-d" src="http://blosc.org/images/codecs-pgo/lz4-decomp-pgo.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We can see here that, similarly to BloscLZ, although the compression speed has not improved significantly, the decompression is now reaching up to 30 GB/s, and for high compression levels, up to 20 GB/s, which is pretty good.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="zstd-1"&gt;
&lt;h2&gt;Zstd&lt;/h2&gt;
&lt;p&gt;First, for GCC without PGO:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="zstd-old-c" src="http://blosc.org/images/codecs-pgo/zstd-comp-gcc-6.3.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="zstd-old-d" src="http://blosc.org/images/codecs-pgo/zstd-decomp-gcc-6.3.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Now with PGO enabled:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="zstd-pgo-c" src="http://blosc.org/images/codecs-pgo/zstd-comp-pgo.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="zstd-pgo-d" src="http://blosc.org/images/codecs-pgo/zstd-decomp-pgo.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Wow, in this case we &lt;em&gt;really&lt;/em&gt; can see important speedups in both compressing and decompressing.  Specially interesting is the decompression case where, for the higher compression levels, Zstd can reach speeds exceeding 20 GB/s (whereas without PGO it was not able to exceed 12 GB/s) which seems a bit crazy provided the wonderful compression ratios that Zstd is able to achieve.  Beyond any doubt, for Write Once Read Multiple scenarios there is no competitor for Zstd, most specially when PGO is used.&lt;/p&gt;
&lt;p&gt;This confirms that, once again, when performance is critical for your applications, PGO should be part of your daily weaponery.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="appendix-hardware-and-software-used"&gt;
&lt;h2&gt;Appendix: Hardware and software used&lt;/h2&gt;
&lt;p&gt;For reference, here it is the configuration that I used for producing the plots in this blog entry.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;CPU: Intel Xeon E3-1245 v5 @ 3.50GHz (4 physical cores with hyper-threading)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OS:  Ubuntu 16.04&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compiler: GCC 6.3.0 (using PGO)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C-Blosc2: 2.0.0a4.dev (2017-07-11)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LZ4 codec: 1.7.5&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Zstd codec: 1.3.0&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;</description><category>LZ4</category><category>PGO</category><category>Zstandard</category><guid>http://blosc.org/posts/codecs-pgo/</guid><pubDate>Wed, 19 Jul 2017 11:32:20 GMT</pubDate></item><item><title>Zstd has just landed in Blosc</title><link>http://blosc.org/posts/zstd-has-just-landed-in-blosc/</link><dc:creator>Francesc Alted</dc:creator><description>&lt;p&gt;&lt;a class="reference external" href="http://www.zstd.net"&gt;Zstd&lt;/a&gt;, aka Zstandard, is a new breed of compression
library that promises to achieve better compression ratios than &lt;a class="reference external" href="http://www.zlib.net/"&gt;Zlib&lt;/a&gt;, and at better speeds too. The fact that Zstd is geared
towards fast compression / decompression since the beginning was an indication
for me that it could be a good fit for Blosc. After some months of
experimentation with Zstd in &lt;a class="reference external" href="https://github.com/Blosc/c-blosc2/pull/6"&gt;Blosc2&lt;/a&gt;, I am really happy to say that I am
quite impressed on how the pair performs.&lt;/p&gt;
&lt;p&gt;And now that the Zstd format has been declared &lt;a class="reference external" href="http://fastcompression.blogspot.com.es/2016_07_03_archive.html"&gt;stable&lt;/a&gt; and that its
API is maturing rapidly, it is a good time for inclusion in the &lt;a class="reference external" href="https://github.com/Blosc/c-blosc/pull/171"&gt;Blosc1&lt;/a&gt; project too. In Blosc1 there was
still a couple of slots available for additional codecs, and after my positive
experiences with Zstd I decided that it would be an excellent candidate to take
one of the free seats (will see which one will take the last one, if any).&lt;/p&gt;
&lt;p&gt;Beware: the Zstd support in Blosc should still be considered in &lt;strong&gt;beta&lt;/strong&gt;
and so it is not recommended to use this new codec in production yet. It is
indeed recommended to start experimenting with it so as to see the kind of
improvements that it can bring to your scenario, and specially report possible
flaws back.&lt;/p&gt;
&lt;section id="a-compression-beast-for-blosc-operation"&gt;
&lt;h2&gt;A compression beast for Blosc operation&lt;/h2&gt;
&lt;p&gt;As said, Zstd is meant to achieve better compression ratios than Zlib, and this
is indeed the &lt;a class="reference external" href="http://www.zstd.net"&gt;case for many situations already&lt;/a&gt;. But it
turns out that Zstd shines specially when faced to the kind of data that is left
after the shuffle (or bitshuffle) filter passes.&lt;/p&gt;
&lt;p&gt;As for one, here it is the typical benchmark plot for compressing with Zstd on
my machine (Intel Xeon E3-1245-v5 @ 3.5GHz), side-by-side with Zlib which was
the codec having the best compression ratios among all the supported inside
Blosc:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="lap-zstd-c" src="http://blosc.org/images/zstd-E3-1245-v5-4p-compr.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="lap-zlib-c" src="http://blosc.org/images/zlib-E3-1245-v5-compr.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As can be seen, Zstd achieves a maximum compression ratio of more than 300x for
this specific dataset, which is quite a lot more than the 70x achieved by Zlib.
But the coolest thing is that we are not paying a performance price for this
increased compression ratio, rather the contrary, because Zstd is clearly
superior (up to a 25%) in compression speed to Zlib.&lt;/p&gt;
&lt;p&gt;But one of the most distinctive features for Blosc is its ability to decompress
data very fast (sometimes faster than memcpy() as I like to remind). And look at
what Zstd is able to achieve in this case:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="lap-zstd-d" src="http://blosc.org/images/zstd-E3-1245-v5-4p.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="lap-zlib-d" src="http://blosc.org/images/zlib-E3-1245-v5.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;With peak speeds larger than 10 GB/s, Zstd can decompress data more than 2x
faster than Zlib peaks (~ 4 GB/s). And more importantly, when it comes to
decompress data at the highest compression level, Zstd can do that about 6x
faster than Zlib (~6 GB/s vs ~1 GB/s), which is a welcome surprise.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="not-the-fastest-but-a-nicely-balanced-one"&gt;
&lt;h2&gt;Not the fastest, but a nicely balanced one&lt;/h2&gt;
&lt;p&gt;Of course, Zstd is still far from the fastest codecs in Blosc. See for example
how the internal BloscLZ codec can perform in this machine:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="lap-blosclz-c" src="http://blosc.org/images/blosclz-E3-1245-v5-compr.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="lap-blosclz-d" src="http://blosc.org/images/blosclz-E3-1245-v5.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But nevertheless, due to its impressive balance between compression ratio and
speed, Zstd is called to be one of the most attractive codecs in Blosc for the
near future.&lt;/p&gt;
&lt;p&gt;As always, all these benchmarks here were made for the specific, synthetic
dataset that I am using for Blosc since the beginning (mainly for
reproducibility purposes). But I am pretty sure that most of the capabilities
shown here will be experienced in a large variety of datasets that Blosc is
meant to tackle (in fact, it would be nice if you can share your experience by
adding a comment below).&lt;/p&gt;
&lt;p&gt;Finally, my special thanks to Yann Collet, the author of Zstd (as well as &lt;a class="reference external" href="http://www.lz4.org/"&gt;LZ4&lt;/a&gt;, also included in Blosc) for putting his genius at the
service of the community by opening not only his code, but also his mind in his
amazing series of blogs about compression: &lt;a class="reference external" href="http://fastcompression.blogspot.com"&gt;http://fastcompression.blogspot.com&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="appendix-what-can-be-expected-in-blosc2"&gt;
&lt;h2&gt;Appendix: What can be expected in Blosc2&lt;/h2&gt;
&lt;p&gt;Blosc2 has support for Zstd contexts and
a new way to split chunks into blocks that makes codecs go faster in general.
Below you have a couple of plots on how the Blosc2/Zstd couple behaves:&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;img alt="blosc2-zstd-c" src="http://blosc.org/images/zstd-E3-1245-v5-compr-blosc2.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;img alt="blosc2-zstd-d" src="http://blosc.org/images/zstd-E3-1245-v5-blosc2.png"&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;As can be seen, in Blosc2 Zstd can get peaks of more than 15 GB/s, almost reaching
memcpy() speed in this machine (~17 GB/s).  Also, decompression speed at the
highest compression ratio can scale when throwing more threads at it (a thing
that Blosc1 is not able to achieve), and easily surpasses 10 GB/s.  Notice
that reaching such a high speed while decompressing a buffer with a really high
compression ratio (~300x) is really impressing.  On his part, compression speed
is a bit less (25%) than in Blosc1 but still quite competitive (and on par with Zlib).&lt;/p&gt;
&lt;p&gt;This is really exciting news to be added on top of the new planned features for Blosc2.&lt;/p&gt;
&lt;/section&gt;</description><category>Zstandard</category><category>Zstd</category><guid>http://blosc.org/posts/zstd-has-just-landed-in-blosc/</guid><pubDate>Wed, 20 Jul 2016 11:32:20 GMT</pubDate></item></channel></rss>